const std = @import("std");
const backend = @import("backend");
const posix = std.posix;

const c = @cImport({
    @cInclude("wayland-client-core.h");
    @cInclude("sys/mman.h");
    @cInclude("unistd.h");
    @cInclude("fcntl.h");
});

const log = std.log.scoped(.wayland_backend);

// Wayland protocol interface definitions (normally generated by wayland-scanner)
// These are the minimal definitions needed for our use case

const wl_interface = extern struct {
    name: [*:0]const u8,
    version: c_int,
    method_count: c_int,
    methods: ?*const anyopaque,
    event_count: c_int,
    events: ?*const anyopaque,
};

// Interface definitions
extern const wl_compositor_interface: wl_interface;
extern const wl_shm_interface: wl_interface;
extern const wl_shm_pool_interface: wl_interface;
extern const wl_buffer_interface: wl_interface;
extern const wl_surface_interface: wl_interface;
extern const wl_seat_interface: wl_interface;
extern const wl_keyboard_interface: wl_interface;
extern const wl_callback_interface: wl_interface;

// XDG shell interfaces - we'll define these ourselves since headers aren't available
const xdg_wm_base_interface_def = wl_interface{
    .name = "xdg_wm_base",
    .version = 1,
    .method_count = 2,
    .methods = null,
    .event_count = 1,
    .events = null,
};

const xdg_surface_interface_def = wl_interface{
    .name = "xdg_surface",
    .version = 1,
    .method_count = 5,
    .methods = null,
    .event_count = 1,
    .events = null,
};

const xdg_toplevel_interface_def = wl_interface{
    .name = "xdg_toplevel",
    .version = 1,
    .method_count = 14,
    .methods = null,
    .event_count = 2,
    .events = null,
};

// Wayland proxy functions
extern fn wl_proxy_marshal_flags(proxy: *anyopaque, opcode: u32, interface: ?*const wl_interface, version: u32, flags: u32, ...) ?*anyopaque;
extern fn wl_proxy_add_listener(proxy: *anyopaque, listener: *const anyopaque, data: ?*anyopaque) c_int;
extern fn wl_proxy_destroy(proxy: *anyopaque) void;
extern fn wl_proxy_get_version(proxy: *anyopaque) u32;

// Wayland display functions
extern fn wl_display_connect(name: ?[*:0]const u8) ?*anyopaque;
extern fn wl_display_disconnect(display: *anyopaque) void;
extern fn wl_display_get_fd(display: *anyopaque) c_int;
extern fn wl_display_dispatch(display: *anyopaque) c_int;
extern fn wl_display_dispatch_pending(display: *anyopaque) c_int;
extern fn wl_display_roundtrip(display: *anyopaque) c_int;
extern fn wl_display_flush(display: *anyopaque) c_int;
extern fn wl_display_prepare_read(display: *anyopaque) c_int;
extern fn wl_display_cancel_read(display: *anyopaque) void;
extern fn wl_display_read_events(display: *anyopaque) c_int;

// Wayland registry functions
extern fn wl_display_get_registry(display: *anyopaque) ?*anyopaque;
extern const wl_registry_interface: wl_interface;

// SHM format constants
const WL_SHM_FORMAT_ARGB8888: u32 = 0;
const WL_SHM_FORMAT_XRGB8888: u32 = 1;

// Keyboard key state
const WL_KEYBOARD_KEY_STATE_PRESSED: u32 = 1;

// Seat capability
const WL_SEAT_CAPABILITY_KEYBOARD: u32 = 2;

/// Wayland backend for windowed display
pub const WaylandBackend = struct {
    allocator: std.mem.Allocator,

    // Wayland core objects
    display: ?*anyopaque,
    registry: ?*anyopaque,
    compositor: ?*anyopaque,
    shm: ?*anyopaque,
    seat: ?*anyopaque,
    keyboard: ?*anyopaque,

    // XDG shell objects
    xdg_wm_base: ?*anyopaque,
    xdg_surface: ?*anyopaque,
    xdg_toplevel: ?*anyopaque,

    // Surface and buffer
    surface: ?*anyopaque,
    buffer: ?*anyopaque,
    shm_data: ?[*]u8,
    shm_size: usize,
    shm_fd: c_int,

    // State
    width: u32,
    height: u32,
    configured: bool,
    closed: bool,
    frame_count: u64,
    ctrl_held: bool,

    // Supported format
    shm_format: u32,
    format_found: bool,

    const Self = @This();

    pub fn init(allocator: std.mem.Allocator) !*Self {
        const self = try allocator.create(Self);
        errdefer allocator.destroy(self);

        self.* = Self{
            .allocator = allocator,
            .display = null,
            .registry = null,
            .compositor = null,
            .shm = null,
            .seat = null,
            .keyboard = null,
            .xdg_wm_base = null,
            .xdg_surface = null,
            .xdg_toplevel = null,
            .surface = null,
            .buffer = null,
            .shm_data = null,
            .shm_size = 0,
            .shm_fd = -1,
            .width = 1920,
            .height = 1080,
            .configured = false,
            .closed = false,
            .frame_count = 0,
            .ctrl_held = false,
            .shm_format = WL_SHM_FORMAT_ARGB8888,
            .format_found = false,
        };

        // Connect to Wayland display
        self.display = wl_display_connect(null);
        if (self.display == null) {
            log.err("failed to connect to Wayland display", .{});
            return error.WaylandConnectionFailed;
        }
        errdefer self.disconnectDisplay();

        // Get registry
        self.registry = wl_display_get_registry(self.display.?);
        if (self.registry == null) {
            return error.WaylandRegistryFailed;
        }

        // Add registry listener
        _ = wl_proxy_add_listener(self.registry.?, &registry_listener, self);

        // Roundtrip to get globals
        _ = wl_display_roundtrip(self.display.?);

        // Verify we have required globals
        if (self.compositor == null) {
            log.err("wl_compositor not available", .{});
            return error.WaylandMissingGlobal;
        }
        if (self.shm == null) {
            log.err("wl_shm not available", .{});
            return error.WaylandMissingGlobal;
        }
        if (self.xdg_wm_base == null) {
            log.err("xdg_wm_base not available", .{});
            return error.WaylandMissingGlobal;
        }

        // Add shm listener
        _ = wl_proxy_add_listener(self.shm.?, &shm_listener, self);
        _ = wl_display_roundtrip(self.display.?);

        // Create surface: wl_compositor.create_surface (opcode 0)
        self.surface = wl_proxy_marshal_flags(
            self.compositor.?,
            0, // create_surface opcode
            &wl_surface_interface,
            wl_proxy_get_version(self.compositor.?),
            0,
        );
        if (self.surface == null) {
            return error.WaylandSurfaceCreationFailed;
        }

        // Create XDG surface: xdg_wm_base.get_xdg_surface (opcode 1)
        self.xdg_surface = wl_proxy_marshal_flags(
            self.xdg_wm_base.?,
            1, // get_xdg_surface opcode
            &xdg_surface_interface_def,
            wl_proxy_get_version(self.xdg_wm_base.?),
            0,
            self.surface.?,
        );
        if (self.xdg_surface == null) {
            return error.XdgSurfaceCreationFailed;
        }
        _ = wl_proxy_add_listener(self.xdg_surface.?, &xdg_surface_listener, self);

        // Create toplevel: xdg_surface.get_toplevel (opcode 1)
        self.xdg_toplevel = wl_proxy_marshal_flags(
            self.xdg_surface.?,
            1, // get_toplevel opcode
            &xdg_toplevel_interface_def,
            wl_proxy_get_version(self.xdg_surface.?),
            0,
        );
        if (self.xdg_toplevel == null) {
            return error.XdgToplevelCreationFailed;
        }
        _ = wl_proxy_add_listener(self.xdg_toplevel.?, &xdg_toplevel_listener, self);

        // Set title: xdg_toplevel.set_title (opcode 2)
        _ = wl_proxy_marshal_flags(
            self.xdg_toplevel.?,
            2, // set_title opcode
            null,
            wl_proxy_get_version(self.xdg_toplevel.?),
            0,
            @as([*:0]const u8, "SemaDraw (Wayland)"),
        );

        // Set app_id: xdg_toplevel.set_app_id (opcode 3)
        _ = wl_proxy_marshal_flags(
            self.xdg_toplevel.?,
            3, // set_app_id opcode
            null,
            wl_proxy_get_version(self.xdg_toplevel.?),
            0,
            @as([*:0]const u8, "semadraw"),
        );

        // Commit surface: wl_surface.commit (opcode 6)
        _ = wl_proxy_marshal_flags(
            self.surface.?,
            6, // commit opcode
            null,
            wl_proxy_get_version(self.surface.?),
            0,
        );

        // Wait for configure
        while (!self.configured and !self.closed) {
            if (wl_display_dispatch(self.display.?) < 0) {
                return error.WaylandDispatchFailed;
            }
        }

        // Create initial buffer
        try self.createBuffer(self.width, self.height);

        log.info("Wayland backend initialized: {}x{}", .{ self.width, self.height });

        return self;
    }

    pub fn deinit(self: *Self) void {
        self.destroyBuffer();

        if (self.xdg_toplevel != null) {
            wl_proxy_destroy(self.xdg_toplevel.?);
        }
        if (self.xdg_surface != null) {
            wl_proxy_destroy(self.xdg_surface.?);
        }
        if (self.surface != null) {
            wl_proxy_destroy(self.surface.?);
        }
        if (self.keyboard != null) {
            wl_proxy_destroy(self.keyboard.?);
        }
        if (self.seat != null) {
            wl_proxy_destroy(self.seat.?);
        }
        if (self.xdg_wm_base != null) {
            wl_proxy_destroy(self.xdg_wm_base.?);
        }
        if (self.shm != null) {
            wl_proxy_destroy(self.shm.?);
        }
        if (self.compositor != null) {
            wl_proxy_destroy(self.compositor.?);
        }
        if (self.registry != null) {
            wl_proxy_destroy(self.registry.?);
        }

        self.disconnectDisplay();
        self.allocator.destroy(self);
    }

    fn disconnectDisplay(self: *Self) void {
        if (self.display != null) {
            wl_display_disconnect(self.display.?);
            self.display = null;
        }
    }

    fn createBuffer(self: *Self, width: u32, height: u32) !void {
        self.destroyBuffer();

        const stride = width * 4;
        const size = stride * height;

        // Create anonymous file for shared memory
        const fd = c.memfd_create("semadraw-shm", 0);
        if (fd < 0) {
            return error.MemfdCreateFailed;
        }
        errdefer _ = c.close(fd);

        if (c.ftruncate(fd, @intCast(size)) < 0) {
            return error.FtruncateFailed;
        }

        const data = c.mmap(null, size, c.PROT_READ | c.PROT_WRITE, c.MAP_SHARED, fd, 0);
        if (data == c.MAP_FAILED) {
            return error.MmapFailed;
        }

        self.shm_data = @ptrCast(data);
        self.shm_size = size;
        self.shm_fd = fd;

        // Create wl_shm_pool: wl_shm.create_pool (opcode 0)
        const pool = wl_proxy_marshal_flags(
            self.shm.?,
            0, // create_pool opcode
            &wl_shm_pool_interface,
            wl_proxy_get_version(self.shm.?),
            0,
            fd,
            @as(i32, @intCast(size)),
        );
        if (pool == null) {
            return error.ShmPoolCreationFailed;
        }
        defer wl_proxy_destroy(pool.?);

        // Create buffer: wl_shm_pool.create_buffer (opcode 0)
        self.buffer = wl_proxy_marshal_flags(
            pool.?,
            0, // create_buffer opcode
            &wl_buffer_interface,
            wl_proxy_get_version(pool.?),
            0,
            @as(i32, 0), // offset
            @as(i32, @intCast(width)), // width
            @as(i32, @intCast(height)), // height
            @as(i32, @intCast(stride)), // stride
            @as(u32, self.shm_format), // format
        );
        if (self.buffer == null) {
            return error.BufferCreationFailed;
        }

        self.width = width;
        self.height = height;

        // Clear buffer
        @memset(self.shm_data.?[0..size], 0);
    }

    fn destroyBuffer(self: *Self) void {
        if (self.buffer != null) {
            wl_proxy_destroy(self.buffer.?);
            self.buffer = null;
        }
        if (self.shm_data != null) {
            _ = c.munmap(self.shm_data, self.shm_size);
            self.shm_data = null;
        }
        if (self.shm_fd >= 0) {
            _ = c.close(self.shm_fd);
            self.shm_fd = -1;
        }
    }

    fn present(self: *Self) void {
        if (self.buffer == null or self.surface == null) return;

        // wl_surface.attach (opcode 1)
        _ = wl_proxy_marshal_flags(
            self.surface.?,
            1,
            null,
            wl_proxy_get_version(self.surface.?),
            0,
            self.buffer.?,
            @as(i32, 0),
            @as(i32, 0),
        );

        // wl_surface.damage_buffer (opcode 9)
        _ = wl_proxy_marshal_flags(
            self.surface.?,
            9,
            null,
            wl_proxy_get_version(self.surface.?),
            0,
            @as(i32, 0),
            @as(i32, 0),
            @as(i32, @intCast(self.width)),
            @as(i32, @intCast(self.height)),
        );

        // wl_surface.commit (opcode 6)
        _ = wl_proxy_marshal_flags(
            self.surface.?,
            6,
            null,
            wl_proxy_get_version(self.surface.?),
            0,
        );
    }

    fn processEvents(self: *Self) bool {
        if (self.display == null) return !self.closed;

        // Non-blocking dispatch
        while (wl_display_prepare_read(self.display.?) != 0) {
            _ = wl_display_dispatch_pending(self.display.?);
        }

        if (wl_display_flush(self.display.?) < 0) {
            wl_display_cancel_read(self.display.?);
            return false;
        }

        // Check for events with zero timeout
        var pfd = posix.pollfd{
            .fd = wl_display_get_fd(self.display.?),
            .events = posix.POLL.IN,
            .revents = 0,
        };

        const ready = posix.poll(@as(*[1]posix.pollfd, &pfd), 0) catch 0;
        if (ready > 0) {
            _ = wl_display_read_events(self.display.?);
            _ = wl_display_dispatch_pending(self.display.?);
        } else {
            wl_display_cancel_read(self.display.?);
        }

        return !self.closed;
    }

    // ========================================================================
    // Wayland listeners
    // ========================================================================

    const RegistryListener = extern struct {
        global: *const fn (?*anyopaque, ?*anyopaque, u32, [*:0]const u8, u32) callconv(.C) void,
        global_remove: *const fn (?*anyopaque, ?*anyopaque, u32) callconv(.C) void,
    };

    const registry_listener = RegistryListener{
        .global = registryGlobal,
        .global_remove = registryGlobalRemove,
    };

    fn registryGlobal(data: ?*anyopaque, registry: ?*anyopaque, name: u32, interface: [*:0]const u8, version: u32) callconv(.C) void {
        const self: *Self = @ptrCast(@alignCast(data));
        _ = version;

        const iface = std.mem.span(interface);

        if (std.mem.eql(u8, iface, "wl_compositor")) {
            self.compositor = wl_proxy_marshal_flags(registry.?, 0, &wl_compositor_interface, 4, 0, name, @as([*:0]const u8, "wl_compositor"), @as(u32, 4));
        } else if (std.mem.eql(u8, iface, "wl_shm")) {
            self.shm = wl_proxy_marshal_flags(registry.?, 0, &wl_shm_interface, 1, 0, name, @as([*:0]const u8, "wl_shm"), @as(u32, 1));
        } else if (std.mem.eql(u8, iface, "xdg_wm_base")) {
            self.xdg_wm_base = wl_proxy_marshal_flags(registry.?, 0, &xdg_wm_base_interface_def, 1, 0, name, @as([*:0]const u8, "xdg_wm_base"), @as(u32, 1));
            if (self.xdg_wm_base != null) {
                _ = wl_proxy_add_listener(self.xdg_wm_base.?, &xdg_wm_base_listener, self);
            }
        } else if (std.mem.eql(u8, iface, "wl_seat")) {
            self.seat = wl_proxy_marshal_flags(registry.?, 0, &wl_seat_interface, 1, 0, name, @as([*:0]const u8, "wl_seat"), @as(u32, 1));
            if (self.seat != null) {
                _ = wl_proxy_add_listener(self.seat.?, &seat_listener, self);
            }
        }
    }

    fn registryGlobalRemove(_: ?*anyopaque, _: ?*anyopaque, _: u32) callconv(.C) void {}

    const ShmListener = extern struct {
        format: *const fn (?*anyopaque, ?*anyopaque, u32) callconv(.C) void,
    };

    const shm_listener = ShmListener{
        .format = shmFormat,
    };

    fn shmFormat(data: ?*anyopaque, _: ?*anyopaque, format: u32) callconv(.C) void {
        const self: *Self = @ptrCast(@alignCast(data));
        if (format == WL_SHM_FORMAT_ARGB8888 or format == WL_SHM_FORMAT_XRGB8888) {
            self.shm_format = format;
            self.format_found = true;
        }
    }

    const XdgWmBaseListener = extern struct {
        ping: *const fn (?*anyopaque, ?*anyopaque, u32) callconv(.C) void,
    };

    const xdg_wm_base_listener = XdgWmBaseListener{
        .ping = xdgWmBasePing,
    };

    fn xdgWmBasePing(_: ?*anyopaque, wm_base: ?*anyopaque, serial: u32) callconv(.C) void {
        // xdg_wm_base.pong (opcode 0)
        _ = wl_proxy_marshal_flags(wm_base.?, 0, null, 1, 0, serial);
    }

    const XdgSurfaceListener = extern struct {
        configure: *const fn (?*anyopaque, ?*anyopaque, u32) callconv(.C) void,
    };

    const xdg_surface_listener = XdgSurfaceListener{
        .configure = xdgSurfaceConfigure,
    };

    fn xdgSurfaceConfigure(data: ?*anyopaque, xdg_surface: ?*anyopaque, serial: u32) callconv(.C) void {
        const self: *Self = @ptrCast(@alignCast(data));
        // xdg_surface.ack_configure (opcode 4)
        _ = wl_proxy_marshal_flags(xdg_surface.?, 4, null, 1, 0, serial);
        self.configured = true;
    }

    const XdgToplevelListener = extern struct {
        configure: *const fn (?*anyopaque, ?*anyopaque, i32, i32, ?*anyopaque) callconv(.C) void,
        close: *const fn (?*anyopaque, ?*anyopaque) callconv(.C) void,
    };

    const xdg_toplevel_listener = XdgToplevelListener{
        .configure = xdgToplevelConfigure,
        .close = xdgToplevelClose,
    };

    fn xdgToplevelConfigure(data: ?*anyopaque, _: ?*anyopaque, width: i32, height: i32, _: ?*anyopaque) callconv(.C) void {
        const self: *Self = @ptrCast(@alignCast(data));
        if (width > 0 and height > 0) {
            if (@as(u32, @intCast(width)) != self.width or @as(u32, @intCast(height)) != self.height) {
                log.info("resize: {}x{} -> {}x{}", .{ self.width, self.height, width, height });
                self.createBuffer(@intCast(width), @intCast(height)) catch |err| {
                    log.err("failed to resize buffer: {}", .{err});
                };
            }
        }
    }

    fn xdgToplevelClose(data: ?*anyopaque, _: ?*anyopaque) callconv(.C) void {
        const self: *Self = @ptrCast(@alignCast(data));
        log.info("window close requested", .{});
        self.closed = true;
    }

    const SeatListener = extern struct {
        capabilities: *const fn (?*anyopaque, ?*anyopaque, u32) callconv(.C) void,
        name: ?*const fn (?*anyopaque, ?*anyopaque, [*:0]const u8) callconv(.C) void,
    };

    const seat_listener = SeatListener{
        .capabilities = seatCapabilities,
        .name = null,
    };

    fn seatCapabilities(data: ?*anyopaque, seat: ?*anyopaque, caps: u32) callconv(.C) void {
        const self: *Self = @ptrCast(@alignCast(data));

        if (caps & WL_SEAT_CAPABILITY_KEYBOARD != 0) {
            if (self.keyboard == null) {
                // wl_seat.get_keyboard (opcode 1)
                self.keyboard = wl_proxy_marshal_flags(seat.?, 1, &wl_keyboard_interface, 1, 0);
                if (self.keyboard != null) {
                    _ = wl_proxy_add_listener(self.keyboard.?, &keyboard_listener, self);
                }
            }
        } else {
            if (self.keyboard != null) {
                wl_proxy_destroy(self.keyboard.?);
                self.keyboard = null;
            }
        }
    }

    const KeyboardListener = extern struct {
        keymap: *const fn (?*anyopaque, ?*anyopaque, u32, i32, u32) callconv(.C) void,
        enter: *const fn (?*anyopaque, ?*anyopaque, u32, ?*anyopaque, ?*anyopaque) callconv(.C) void,
        leave: *const fn (?*anyopaque, ?*anyopaque, u32, ?*anyopaque) callconv(.C) void,
        key: *const fn (?*anyopaque, ?*anyopaque, u32, u32, u32, u32) callconv(.C) void,
        modifiers: *const fn (?*anyopaque, ?*anyopaque, u32, u32, u32, u32, u32) callconv(.C) void,
        repeat_info: ?*const fn (?*anyopaque, ?*anyopaque, i32, i32) callconv(.C) void,
    };

    const keyboard_listener = KeyboardListener{
        .keymap = keyboardKeymap,
        .enter = keyboardEnter,
        .leave = keyboardLeave,
        .key = keyboardKey,
        .modifiers = keyboardModifiers,
        .repeat_info = null,
    };

    fn keyboardKeymap(_: ?*anyopaque, _: ?*anyopaque, _: u32, _: i32, _: u32) callconv(.C) void {}
    fn keyboardEnter(_: ?*anyopaque, _: ?*anyopaque, _: u32, _: ?*anyopaque, _: ?*anyopaque) callconv(.C) void {}
    fn keyboardLeave(_: ?*anyopaque, _: ?*anyopaque, _: u32, _: ?*anyopaque) callconv(.C) void {}

    fn keyboardKey(data: ?*anyopaque, _: ?*anyopaque, _: u32, _: u32, key: u32, state: u32) callconv(.C) void {
        const self: *Self = @ptrCast(@alignCast(data));

        // Key pressed
        if (state == WL_KEYBOARD_KEY_STATE_PRESSED) {
            // KEY_Q = 16
            if (key == 16 and self.ctrl_held) {
                log.info("Ctrl+Q pressed, closing window", .{});
                self.closed = true;
            }
        }
    }

    fn keyboardModifiers(data: ?*anyopaque, _: ?*anyopaque, _: u32, mods_depressed: u32, _: u32, _: u32, _: u32) callconv(.C) void {
        const self: *Self = @ptrCast(@alignCast(data));
        // Check for Ctrl (bit 2 in typical xkb layouts)
        self.ctrl_held = (mods_depressed & 4) != 0;
    }

    // ========================================================================
    // Backend interface
    // ========================================================================

    fn getCapabilitiesImpl(_: *anyopaque) backend.Capabilities {
        return .{
            .name = "wayland",
            .max_width = 8192,
            .max_height = 8192,
            .supports_aa = true,
            .hardware_accelerated = false,
            .can_present = true,
        };
    }

    fn initFramebufferImpl(ctx: *anyopaque, config: backend.FramebufferConfig) anyerror!void {
        const self: *Self = @ptrCast(@alignCast(ctx));

        if (config.width != self.width or config.height != self.height) {
            try self.createBuffer(config.width, config.height);
        }
    }

    fn renderImpl(ctx: *anyopaque, request: backend.RenderRequest) anyerror!backend.RenderResult {
        const self: *Self = @ptrCast(@alignCast(ctx));
        const start_time = std.time.nanoTimestamp();

        if (!self.processEvents()) {
            return backend.RenderResult.failure(request.surface_id, "window closed");
        }

        const fb = self.shm_data orelse {
            return backend.RenderResult.failure(request.surface_id, "no framebuffer");
        };

        // Clear if requested (ARGB format)
        if (request.clear_color) |color| {
            const a: u8 = @intFromFloat(@min(255.0, @max(0.0, color[3] * 255.0)));
            const r: u8 = @intFromFloat(@min(255.0, @max(0.0, color[0] * 255.0)));
            const g: u8 = @intFromFloat(@min(255.0, @max(0.0, color[1] * 255.0)));
            const b: u8 = @intFromFloat(@min(255.0, @max(0.0, color[2] * 255.0)));

            const pixel: u32 = (@as(u32, a) << 24) | (@as(u32, r) << 16) | (@as(u32, g) << 8) | @as(u32, b);

            const pixels: [*]u32 = @ptrCast(@alignCast(fb));
            const count = self.width * self.height;
            for (0..count) |i| {
                pixels[i] = pixel;
            }
        }

        // TODO: Parse and render SDCS commands
        _ = request.sdcs_data;

        // Present
        self.present();

        self.frame_count += 1;
        const end_time = std.time.nanoTimestamp();

        return backend.RenderResult.success(
            request.surface_id,
            self.frame_count,
            @intCast(end_time - start_time),
        );
    }

    fn getPixelsImpl(ctx: *anyopaque) ?[]u8 {
        const self: *Self = @ptrCast(@alignCast(ctx));
        if (self.shm_data) |data| {
            return data[0..self.shm_size];
        }
        return null;
    }

    fn resizeImpl(ctx: *anyopaque, width: u32, height: u32) anyerror!void {
        const self: *Self = @ptrCast(@alignCast(ctx));
        try self.createBuffer(width, height);
    }

    fn pollEventsImpl(ctx: *anyopaque) bool {
        const self: *Self = @ptrCast(@alignCast(ctx));
        return self.processEvents();
    }

    fn deinitImpl(ctx: *anyopaque) void {
        const self: *Self = @ptrCast(@alignCast(ctx));
        self.deinit();
    }

    pub const vtable = backend.Backend.VTable{
        .getCapabilities = getCapabilitiesImpl,
        .initFramebuffer = initFramebufferImpl,
        .render = renderImpl,
        .getPixels = getPixelsImpl,
        .resize = resizeImpl,
        .pollEvents = pollEventsImpl,
        .deinit = deinitImpl,
    };

    pub fn toBackend(self: *Self) backend.Backend {
        return .{
            .ptr = self,
            .vtable = &vtable,
        };
    }
};

/// Create a Wayland backend
pub fn create(allocator: std.mem.Allocator) !backend.Backend {
    const wl = try WaylandBackend.init(allocator);
    return wl.toBackend();
}
