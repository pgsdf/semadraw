const std = @import("std");
const backend = @import("backend");
const posix = std.posix;

const c = @cImport({
    @cInclude("wayland-client-core.h");
    @cInclude("sys/mman.h");
    @cInclude("unistd.h");
    @cInclude("fcntl.h");
});

const log = std.log.scoped(.wayland_backend);

// Wayland protocol interface definitions (normally generated by wayland-scanner)
// These are the minimal definitions needed for our use case

const wl_interface = extern struct {
    name: [*:0]const u8,
    version: c_int,
    method_count: c_int,
    methods: ?*const anyopaque,
    event_count: c_int,
    events: ?*const anyopaque,
};

// Interface definitions
extern const wl_compositor_interface: wl_interface;
extern const wl_shm_interface: wl_interface;
extern const wl_shm_pool_interface: wl_interface;
extern const wl_buffer_interface: wl_interface;
extern const wl_surface_interface: wl_interface;
extern const wl_seat_interface: wl_interface;
extern const wl_keyboard_interface: wl_interface;
extern const wl_pointer_interface: wl_interface;
extern const wl_callback_interface: wl_interface;
extern const wl_data_device_manager_interface: wl_interface;
extern const wl_data_device_interface: wl_interface;
extern const wl_data_source_interface: wl_interface;
extern const wl_data_offer_interface: wl_interface;

// XDG shell interfaces - we'll define these ourselves since headers aren't available
const xdg_wm_base_interface_def = wl_interface{
    .name = "xdg_wm_base",
    .version = 1,
    .method_count = 2,
    .methods = null,
    .event_count = 1,
    .events = null,
};

const xdg_surface_interface_def = wl_interface{
    .name = "xdg_surface",
    .version = 1,
    .method_count = 5,
    .methods = null,
    .event_count = 1,
    .events = null,
};

const xdg_toplevel_interface_def = wl_interface{
    .name = "xdg_toplevel",
    .version = 1,
    .method_count = 14,
    .methods = null,
    .event_count = 2,
    .events = null,
};

// Wayland proxy functions
extern fn wl_proxy_marshal_flags(proxy: *anyopaque, opcode: u32, interface: ?*const wl_interface, version: u32, flags: u32, ...) ?*anyopaque;
extern fn wl_proxy_add_listener(proxy: *anyopaque, listener: *const anyopaque, data: ?*anyopaque) c_int;
extern fn wl_proxy_destroy(proxy: *anyopaque) void;
extern fn wl_proxy_get_version(proxy: *anyopaque) u32;

// Wayland display functions
extern fn wl_display_connect(name: ?[*:0]const u8) ?*anyopaque;
extern fn wl_display_disconnect(display: *anyopaque) void;
extern fn wl_display_get_fd(display: *anyopaque) c_int;
extern fn wl_display_dispatch(display: *anyopaque) c_int;
extern fn wl_display_dispatch_pending(display: *anyopaque) c_int;
extern fn wl_display_roundtrip(display: *anyopaque) c_int;
extern fn wl_display_flush(display: *anyopaque) c_int;
extern fn wl_display_prepare_read(display: *anyopaque) c_int;
extern fn wl_display_cancel_read(display: *anyopaque) void;
extern fn wl_display_read_events(display: *anyopaque) c_int;

// Wayland registry interface
extern const wl_registry_interface: wl_interface;

// wl_display opcodes
const WL_DISPLAY_GET_REGISTRY: u32 = 1;

// SHM format constants
const WL_SHM_FORMAT_ARGB8888: u32 = 0;
const WL_SHM_FORMAT_XRGB8888: u32 = 1;

// Keyboard key state
const WL_KEYBOARD_KEY_STATE_PRESSED: u32 = 1;

// Seat capability
const WL_SEAT_CAPABILITY_POINTER: u32 = 1;
const WL_SEAT_CAPABILITY_KEYBOARD: u32 = 2;

/// Wayland backend for windowed display
pub const WaylandBackend = struct {
    allocator: std.mem.Allocator,

    // Wayland core objects
    display: ?*anyopaque,
    registry: ?*anyopaque,
    compositor: ?*anyopaque,
    shm: ?*anyopaque,
    seat: ?*anyopaque,
    keyboard: ?*anyopaque,

    // XDG shell objects
    xdg_wm_base: ?*anyopaque,
    xdg_surface: ?*anyopaque,
    xdg_toplevel: ?*anyopaque,

    // Surface and buffer
    surface: ?*anyopaque,
    buffer: ?*anyopaque,
    shm_data: ?[*]u8,
    shm_size: usize,
    shm_fd: c_int,

    // State
    width: u32,
    height: u32,
    configured: bool,
    closed: bool,
    frame_count: u64,
    ctrl_held: bool,

    // Supported format
    shm_format: u32,
    format_found: bool,
    // Rendering protection to prevent resize during render
    rendering: bool,
    pending_resize: ?struct { width: u32, height: u32 },

    // Keyboard event queue
    key_events: [backend.MAX_KEY_EVENTS]backend.KeyEvent,
    key_event_count: usize,
    // Mouse event queue
    mouse_events: [backend.MAX_MOUSE_EVENTS]backend.MouseEvent,
    mouse_event_count: usize,
    // Modifier state tracking
    modifier_state: u8,
    // Mouse pointer
    pointer: ?*anyopaque,
    // Mouse position
    mouse_x: i32,
    mouse_y: i32,

    // Clipboard support (wl_data_device)
    data_device_manager: ?*anyopaque,
    data_device: ?*anyopaque,
    data_source: ?*anyopaque,
    current_offer: ?*anyopaque,
    clipboard_data: ?[]u8,
    primary_data: ?[]u8,
    clipboard_request_pending: bool,
    clipboard_request_selection: u8,
    pending_offer_mime: bool,
    serial: u32,

    const Self = @This();

    pub fn init(allocator: std.mem.Allocator) !*Self {
        const self = try allocator.create(Self);
        errdefer allocator.destroy(self);

        self.* = Self{
            .allocator = allocator,
            .display = null,
            .registry = null,
            .compositor = null,
            .shm = null,
            .seat = null,
            .keyboard = null,
            .xdg_wm_base = null,
            .xdg_surface = null,
            .xdg_toplevel = null,
            .surface = null,
            .buffer = null,
            .shm_data = null,
            .shm_size = 0,
            .shm_fd = -1,
            .width = 1920,
            .height = 1080,
            .configured = false,
            .closed = false,
            .frame_count = 0,
            .ctrl_held = false,
            .shm_format = WL_SHM_FORMAT_ARGB8888,
            .format_found = false,
            .rendering = false,
            .pending_resize = null,
            .key_events = undefined,
            .key_event_count = 0,
            .mouse_events = undefined,
            .mouse_event_count = 0,
            .modifier_state = 0,
            .pointer = null,
            .mouse_x = 0,
            .mouse_y = 0,
            // Clipboard
            .data_device_manager = null,
            .data_device = null,
            .data_source = null,
            .current_offer = null,
            .clipboard_data = null,
            .primary_data = null,
            .clipboard_request_pending = false,
            .clipboard_request_selection = 0,
            .pending_offer_mime = false,
            .serial = 0,
        };

        // Connect to Wayland display
        self.display = wl_display_connect(null);
        if (self.display == null) {
            log.err("failed to connect to Wayland display", .{});
            return error.WaylandConnectionFailed;
        }
        errdefer self.disconnectDisplay();

        // Get registry: wl_display.get_registry (opcode 1)
        self.registry = wl_proxy_marshal_flags(
            self.display.?,
            WL_DISPLAY_GET_REGISTRY,
            &wl_registry_interface,
            1, // version
            0, // flags
        );
        if (self.registry == null) {
            return error.WaylandRegistryFailed;
        }

        // Add registry listener
        _ = wl_proxy_add_listener(self.registry.?, &registry_listener, self);

        // Roundtrip to get globals
        _ = wl_display_roundtrip(self.display.?);

        // Verify we have required globals
        if (self.compositor == null) {
            log.err("wl_compositor not available", .{});
            return error.WaylandMissingGlobal;
        }
        if (self.shm == null) {
            log.err("wl_shm not available", .{});
            return error.WaylandMissingGlobal;
        }
        if (self.xdg_wm_base == null) {
            log.err("xdg_wm_base not available", .{});
            return error.WaylandMissingGlobal;
        }

        // Add shm listener
        _ = wl_proxy_add_listener(self.shm.?, &shm_listener, self);
        _ = wl_display_roundtrip(self.display.?);

        // Create surface: wl_compositor.create_surface (opcode 0)
        self.surface = wl_proxy_marshal_flags(
            self.compositor.?,
            0, // create_surface opcode
            &wl_surface_interface,
            wl_proxy_get_version(self.compositor.?),
            0,
        );
        if (self.surface == null) {
            return error.WaylandSurfaceCreationFailed;
        }

        // Create XDG surface: xdg_wm_base.get_xdg_surface (opcode 1)
        self.xdg_surface = wl_proxy_marshal_flags(
            self.xdg_wm_base.?,
            1, // get_xdg_surface opcode
            &xdg_surface_interface_def,
            wl_proxy_get_version(self.xdg_wm_base.?),
            0,
            self.surface.?,
        );
        if (self.xdg_surface == null) {
            return error.XdgSurfaceCreationFailed;
        }
        _ = wl_proxy_add_listener(self.xdg_surface.?, &xdg_surface_listener, self);

        // Create toplevel: xdg_surface.get_toplevel (opcode 1)
        self.xdg_toplevel = wl_proxy_marshal_flags(
            self.xdg_surface.?,
            1, // get_toplevel opcode
            &xdg_toplevel_interface_def,
            wl_proxy_get_version(self.xdg_surface.?),
            0,
        );
        if (self.xdg_toplevel == null) {
            return error.XdgToplevelCreationFailed;
        }
        _ = wl_proxy_add_listener(self.xdg_toplevel.?, &xdg_toplevel_listener, self);

        // Set title: xdg_toplevel.set_title (opcode 2)
        _ = wl_proxy_marshal_flags(
            self.xdg_toplevel.?,
            2, // set_title opcode
            null,
            wl_proxy_get_version(self.xdg_toplevel.?),
            0,
            @as([*:0]const u8, "SemaDraw (Wayland)"),
        );

        // Set app_id: xdg_toplevel.set_app_id (opcode 3)
        _ = wl_proxy_marshal_flags(
            self.xdg_toplevel.?,
            3, // set_app_id opcode
            null,
            wl_proxy_get_version(self.xdg_toplevel.?),
            0,
            @as([*:0]const u8, "semadraw"),
        );

        // Commit surface: wl_surface.commit (opcode 6)
        _ = wl_proxy_marshal_flags(
            self.surface.?,
            6, // commit opcode
            null,
            wl_proxy_get_version(self.surface.?),
            0,
        );

        // Wait for configure
        while (!self.configured and !self.closed) {
            if (wl_display_dispatch(self.display.?) < 0) {
                return error.WaylandDispatchFailed;
            }
        }

        // Create initial buffer
        try self.createBuffer(self.width, self.height);

        log.info("Wayland backend initialized: {}x{}", .{ self.width, self.height });

        return self;
    }

    pub fn deinit(self: *Self) void {
        self.destroyBuffer();

        if (self.xdg_toplevel != null) {
            wl_proxy_destroy(self.xdg_toplevel.?);
        }
        if (self.xdg_surface != null) {
            wl_proxy_destroy(self.xdg_surface.?);
        }
        if (self.surface != null) {
            wl_proxy_destroy(self.surface.?);
        }
        if (self.keyboard != null) {
            wl_proxy_destroy(self.keyboard.?);
        }
        if (self.pointer != null) {
            wl_proxy_destroy(self.pointer.?);
        }
        if (self.data_source != null) {
            wl_proxy_destroy(self.data_source.?);
        }
        if (self.data_device != null) {
            wl_proxy_destroy(self.data_device.?);
        }
        if (self.data_device_manager != null) {
            wl_proxy_destroy(self.data_device_manager.?);
        }
        if (self.seat != null) {
            wl_proxy_destroy(self.seat.?);
        }
        if (self.xdg_wm_base != null) {
            wl_proxy_destroy(self.xdg_wm_base.?);
        }
        if (self.shm != null) {
            wl_proxy_destroy(self.shm.?);
        }
        if (self.compositor != null) {
            wl_proxy_destroy(self.compositor.?);
        }
        if (self.registry != null) {
            wl_proxy_destroy(self.registry.?);
        }

        // Free clipboard data
        if (self.clipboard_data) |data| {
            self.allocator.free(data);
        }
        if (self.primary_data) |data| {
            self.allocator.free(data);
        }

        self.disconnectDisplay();
        self.allocator.destroy(self);
    }

    fn disconnectDisplay(self: *Self) void {
        if (self.display != null) {
            wl_display_disconnect(self.display.?);
            self.display = null;
        }
    }

    fn createBuffer(self: *Self, width: u32, height: u32) !void {
        self.destroyBuffer();

        const stride = width * 4;
        const size = stride * height;

        // Create anonymous file for shared memory
        const fd = c.memfd_create("semadraw-shm", 0);
        if (fd < 0) {
            return error.MemfdCreateFailed;
        }
        errdefer _ = c.close(fd);

        if (c.ftruncate(fd, @intCast(size)) < 0) {
            return error.FtruncateFailed;
        }

        const data = c.mmap(null, size, c.PROT_READ | c.PROT_WRITE, c.MAP_SHARED, fd, 0);
        if (data == c.MAP_FAILED) {
            return error.MmapFailed;
        }

        self.shm_data = @ptrCast(data);
        self.shm_size = size;
        self.shm_fd = fd;

        // Create wl_shm_pool: wl_shm.create_pool (opcode 0)
        const pool = wl_proxy_marshal_flags(
            self.shm.?,
            0, // create_pool opcode
            &wl_shm_pool_interface,
            wl_proxy_get_version(self.shm.?),
            0,
            fd,
            @as(i32, @intCast(size)),
        );
        if (pool == null) {
            return error.ShmPoolCreationFailed;
        }
        defer wl_proxy_destroy(pool.?);

        // Create buffer: wl_shm_pool.create_buffer (opcode 0)
        self.buffer = wl_proxy_marshal_flags(
            pool.?,
            0, // create_buffer opcode
            &wl_buffer_interface,
            wl_proxy_get_version(pool.?),
            0,
            @as(i32, 0), // offset
            @as(i32, @intCast(width)), // width
            @as(i32, @intCast(height)), // height
            @as(i32, @intCast(stride)), // stride
            @as(u32, self.shm_format), // format
        );
        if (self.buffer == null) {
            return error.BufferCreationFailed;
        }

        self.width = width;
        self.height = height;

        // Clear buffer
        @memset(self.shm_data.?[0..size], 0);
    }

    fn destroyBuffer(self: *Self) void {
        if (self.buffer != null) {
            wl_proxy_destroy(self.buffer.?);
            self.buffer = null;
        }
        if (self.shm_data != null) {
            _ = c.munmap(self.shm_data, self.shm_size);
            self.shm_data = null;
        }
        if (self.shm_fd >= 0) {
            _ = c.close(self.shm_fd);
            self.shm_fd = -1;
        }
    }

    fn present(self: *Self) void {
        if (self.buffer == null or self.surface == null) return;

        // wl_surface.attach (opcode 1)
        _ = wl_proxy_marshal_flags(
            self.surface.?,
            1,
            null,
            wl_proxy_get_version(self.surface.?),
            0,
            self.buffer.?,
            @as(i32, 0),
            @as(i32, 0),
        );

        // wl_surface.damage_buffer (opcode 9)
        _ = wl_proxy_marshal_flags(
            self.surface.?,
            9,
            null,
            wl_proxy_get_version(self.surface.?),
            0,
            @as(i32, 0),
            @as(i32, 0),
            @as(i32, @intCast(self.width)),
            @as(i32, @intCast(self.height)),
        );

        // wl_surface.commit (opcode 6)
        _ = wl_proxy_marshal_flags(
            self.surface.?,
            6,
            null,
            wl_proxy_get_version(self.surface.?),
            0,
        );
    }

    fn processEvents(self: *Self) bool {
        if (self.display == null) return !self.closed;

        // Non-blocking dispatch
        while (wl_display_prepare_read(self.display.?) != 0) {
            _ = wl_display_dispatch_pending(self.display.?);
        }

        if (wl_display_flush(self.display.?) < 0) {
            wl_display_cancel_read(self.display.?);
            return false;
        }

        // Check for events with zero timeout
        var pfd = posix.pollfd{
            .fd = wl_display_get_fd(self.display.?),
            .events = posix.POLL.IN,
            .revents = 0,
        };

        const ready = posix.poll(@as(*[1]posix.pollfd, &pfd), 0) catch 0;
        if (ready > 0) {
            _ = wl_display_read_events(self.display.?);
            _ = wl_display_dispatch_pending(self.display.?);
        } else {
            wl_display_cancel_read(self.display.?);
        }

        return !self.closed;
    }

    // ========================================================================
    // Wayland listeners
    // ========================================================================

    const RegistryListener = extern struct {
        global: *const fn (?*anyopaque, ?*anyopaque, u32, [*:0]const u8, u32) callconv(.c) void,
        global_remove: *const fn (?*anyopaque, ?*anyopaque, u32) callconv(.c) void,
    };

    const registry_listener = RegistryListener{
        .global = registryGlobal,
        .global_remove = registryGlobalRemove,
    };

    fn registryGlobal(data: ?*anyopaque, registry: ?*anyopaque, name: u32, interface: [*:0]const u8, version: u32) callconv(.c) void {
        const self: *Self = @ptrCast(@alignCast(data));
        const iface = std.mem.span(interface);

        if (std.mem.eql(u8, iface, "wl_compositor")) {
            self.compositor = wl_proxy_marshal_flags(registry.?, 0, &wl_compositor_interface, 4, 0, name, @as([*:0]const u8, "wl_compositor"), @as(u32, 4));
        } else if (std.mem.eql(u8, iface, "wl_shm")) {
            self.shm = wl_proxy_marshal_flags(registry.?, 0, &wl_shm_interface, 1, 0, name, @as([*:0]const u8, "wl_shm"), @as(u32, 1));
        } else if (std.mem.eql(u8, iface, "xdg_wm_base")) {
            self.xdg_wm_base = wl_proxy_marshal_flags(registry.?, 0, &xdg_wm_base_interface_def, 1, 0, name, @as([*:0]const u8, "xdg_wm_base"), @as(u32, 1));
            if (self.xdg_wm_base != null) {
                _ = wl_proxy_add_listener(self.xdg_wm_base.?, &xdg_wm_base_listener, self);
            }
        } else if (std.mem.eql(u8, iface, "wl_seat")) {
            self.seat = wl_proxy_marshal_flags(registry.?, 0, &wl_seat_interface, 1, 0, name, @as([*:0]const u8, "wl_seat"), @as(u32, 1));
            if (self.seat != null) {
                _ = wl_proxy_add_listener(self.seat.?, &seat_listener, self);
            }
        } else if (std.mem.eql(u8, iface, "wl_data_device_manager")) {
            // Bind to data device manager for clipboard support (version 3 for primary selection)
            const bind_version: u32 = @min(version, 3);
            self.data_device_manager = wl_proxy_marshal_flags(registry.?, 0, &wl_data_device_manager_interface, bind_version, 0, name, @as([*:0]const u8, "wl_data_device_manager"), bind_version);
        }
    }

    fn registryGlobalRemove(_: ?*anyopaque, _: ?*anyopaque, _: u32) callconv(.c) void {}

    const ShmListener = extern struct {
        format: *const fn (?*anyopaque, ?*anyopaque, u32) callconv(.c) void,
    };

    const shm_listener = ShmListener{
        .format = shmFormat,
    };

    fn shmFormat(data: ?*anyopaque, _: ?*anyopaque, format: u32) callconv(.c) void {
        const self: *Self = @ptrCast(@alignCast(data));
        if (format == WL_SHM_FORMAT_ARGB8888 or format == WL_SHM_FORMAT_XRGB8888) {
            self.shm_format = format;
            self.format_found = true;
        }
    }

    const XdgWmBaseListener = extern struct {
        ping: *const fn (?*anyopaque, ?*anyopaque, u32) callconv(.c) void,
    };

    const xdg_wm_base_listener = XdgWmBaseListener{
        .ping = xdgWmBasePing,
    };

    fn xdgWmBasePing(_: ?*anyopaque, wm_base: ?*anyopaque, serial: u32) callconv(.c) void {
        // xdg_wm_base.pong (opcode 0)
        _ = wl_proxy_marshal_flags(wm_base.?, 0, null, 1, 0, serial);
    }

    const XdgSurfaceListener = extern struct {
        configure: *const fn (?*anyopaque, ?*anyopaque, u32) callconv(.c) void,
    };

    const xdg_surface_listener = XdgSurfaceListener{
        .configure = xdgSurfaceConfigure,
    };

    fn xdgSurfaceConfigure(data: ?*anyopaque, xdg_surface: ?*anyopaque, serial: u32) callconv(.c) void {
        const self: *Self = @ptrCast(@alignCast(data));
        // xdg_surface.ack_configure (opcode 4)
        _ = wl_proxy_marshal_flags(xdg_surface.?, 4, null, 1, 0, serial);
        self.configured = true;
    }

    const XdgToplevelListener = extern struct {
        configure: *const fn (?*anyopaque, ?*anyopaque, i32, i32, ?*anyopaque) callconv(.c) void,
        close: *const fn (?*anyopaque, ?*anyopaque) callconv(.c) void,
    };

    const xdg_toplevel_listener = XdgToplevelListener{
        .configure = xdgToplevelConfigure,
        .close = xdgToplevelClose,
    };

    fn xdgToplevelConfigure(data: ?*anyopaque, _: ?*anyopaque, width: i32, height: i32, _: ?*anyopaque) callconv(.c) void {
        const self: *Self = @ptrCast(@alignCast(data));
        if (width > 0 and height > 0) {
            const new_width: u32 = @intCast(width);
            const new_height: u32 = @intCast(height);
            if (new_width != self.width or new_height != self.height) {
                // Defer resize if currently rendering to prevent use-after-free
                if (self.rendering) {
                    self.pending_resize = .{ .width = new_width, .height = new_height };
                    return;
                }
                log.info("resize: {}x{} -> {}x{}", .{ self.width, self.height, width, height });
                self.createBuffer(new_width, new_height) catch |err| {
                    log.err("failed to resize buffer: {}", .{err});
                };
            }
        }
    }

    fn xdgToplevelClose(data: ?*anyopaque, _: ?*anyopaque) callconv(.c) void {
        const self: *Self = @ptrCast(@alignCast(data));
        log.info("window close requested", .{});
        self.closed = true;
    }

    const SeatListener = extern struct {
        capabilities: *const fn (?*anyopaque, ?*anyopaque, u32) callconv(.c) void,
        name: ?*const fn (?*anyopaque, ?*anyopaque, [*:0]const u8) callconv(.c) void,
    };

    const seat_listener = SeatListener{
        .capabilities = seatCapabilities,
        .name = null,
    };

    fn seatCapabilities(data: ?*anyopaque, seat: ?*anyopaque, caps: u32) callconv(.c) void {
        const self: *Self = @ptrCast(@alignCast(data));

        // Handle keyboard capability
        if (caps & WL_SEAT_CAPABILITY_KEYBOARD != 0) {
            if (self.keyboard == null) {
                // wl_seat.get_keyboard (opcode 1)
                self.keyboard = wl_proxy_marshal_flags(seat.?, 1, &wl_keyboard_interface, 1, 0);
                if (self.keyboard != null) {
                    _ = wl_proxy_add_listener(self.keyboard.?, &keyboard_listener, self);
                }
            }
        } else {
            if (self.keyboard != null) {
                wl_proxy_destroy(self.keyboard.?);
                self.keyboard = null;
            }
        }

        // Handle pointer capability
        if (caps & WL_SEAT_CAPABILITY_POINTER != 0) {
            if (self.pointer == null) {
                // wl_seat.get_pointer (opcode 0)
                self.pointer = wl_proxy_marshal_flags(seat.?, 0, &wl_pointer_interface, 1, 0);
                if (self.pointer != null) {
                    _ = wl_proxy_add_listener(self.pointer.?, &pointer_listener, self);
                }
            }
        } else {
            if (self.pointer != null) {
                wl_proxy_destroy(self.pointer.?);
                self.pointer = null;
            }
        }

        // Create data device for clipboard once we have the seat
        if (self.data_device == null and self.data_device_manager != null) {
            // wl_data_device_manager.get_data_device (opcode 1)
            self.data_device = wl_proxy_marshal_flags(
                self.data_device_manager.?,
                1, // get_data_device opcode
                &wl_data_device_interface,
                wl_proxy_get_version(self.data_device_manager.?),
                0,
                seat.?,
            );
            if (self.data_device != null) {
                _ = wl_proxy_add_listener(self.data_device.?, &data_device_listener, self);
                log.info("clipboard support enabled (wl_data_device)", .{});
            }
        }
    }

    const KeyboardListener = extern struct {
        keymap: *const fn (?*anyopaque, ?*anyopaque, u32, i32, u32) callconv(.c) void,
        enter: *const fn (?*anyopaque, ?*anyopaque, u32, ?*anyopaque, ?*anyopaque) callconv(.c) void,
        leave: *const fn (?*anyopaque, ?*anyopaque, u32, ?*anyopaque) callconv(.c) void,
        key: *const fn (?*anyopaque, ?*anyopaque, u32, u32, u32, u32) callconv(.c) void,
        modifiers: *const fn (?*anyopaque, ?*anyopaque, u32, u32, u32, u32, u32) callconv(.c) void,
        repeat_info: ?*const fn (?*anyopaque, ?*anyopaque, i32, i32) callconv(.c) void,
    };

    const keyboard_listener = KeyboardListener{
        .keymap = keyboardKeymap,
        .enter = keyboardEnter,
        .leave = keyboardLeave,
        .key = keyboardKey,
        .modifiers = keyboardModifiers,
        .repeat_info = null,
    };

    fn keyboardKeymap(_: ?*anyopaque, _: ?*anyopaque, _: u32, _: i32, _: u32) callconv(.c) void {}

    fn keyboardEnter(data: ?*anyopaque, _: ?*anyopaque, serial: u32, _: ?*anyopaque, _: ?*anyopaque) callconv(.c) void {
        const self: *Self = @ptrCast(@alignCast(data));
        self.serial = serial; // Capture serial for clipboard operations
    }

    fn keyboardLeave(_: ?*anyopaque, _: ?*anyopaque, _: u32, _: ?*anyopaque) callconv(.c) void {}

    fn keyboardKey(data: ?*anyopaque, _: ?*anyopaque, serial: u32, _: u32, key: u32, state: u32) callconv(.c) void {
        const self: *Self = @ptrCast(@alignCast(data));
        self.serial = serial; // Capture serial for clipboard operations
        const pressed = state == WL_KEYBOARD_KEY_STATE_PRESSED;

        // Handle Ctrl+Q to close window
        if (pressed and key == 16 and self.ctrl_held) {
            log.info("Ctrl+Q pressed, closing window", .{});
            self.closed = true;
            return;
        }

        // Queue the key event
        if (self.key_event_count < backend.MAX_KEY_EVENTS) {
            self.key_events[self.key_event_count] = .{
                .key_code = key,
                .modifiers = self.modifier_state,
                .pressed = pressed,
            };
            self.key_event_count += 1;
        } else {
            log.warn("key event queue overflow, dropping key={} pressed={}", .{ key, pressed });
        }
    }

    fn keyboardModifiers(data: ?*anyopaque, _: ?*anyopaque, _: u32, mods_depressed: u32, _: u32, _: u32, _: u32) callconv(.c) void {
        const self: *Self = @ptrCast(@alignCast(data));

        // Map xkb modifier bits to our modifier format
        // xkb: bit 0 = shift, bit 1 = caps, bit 2 = ctrl, bit 3 = mod1 (alt)
        // Our format: bit 0 = shift, bit 1 = alt, bit 2 = ctrl, bit 3 = meta
        var modifiers: u8 = 0;
        if (mods_depressed & 1 != 0) modifiers |= 0x01; // Shift
        if (mods_depressed & 8 != 0) modifiers |= 0x02; // Alt (mod1)
        if (mods_depressed & 4 != 0) modifiers |= 0x04; // Ctrl

        self.modifier_state = modifiers;
        self.ctrl_held = (modifiers & 0x04) != 0;
    }

    // Pointer listener
    const PointerListener = extern struct {
        enter: *const fn (?*anyopaque, ?*anyopaque, u32, ?*anyopaque, i32, i32) callconv(.c) void,
        leave: *const fn (?*anyopaque, ?*anyopaque, u32, ?*anyopaque) callconv(.c) void,
        motion: *const fn (?*anyopaque, ?*anyopaque, u32, i32, i32) callconv(.c) void,
        button: *const fn (?*anyopaque, ?*anyopaque, u32, u32, u32, u32) callconv(.c) void,
        axis: *const fn (?*anyopaque, ?*anyopaque, u32, u32, i32) callconv(.c) void,
    };

    const pointer_listener = PointerListener{
        .enter = pointerEnter,
        .leave = pointerLeave,
        .motion = pointerMotion,
        .button = pointerButton,
        .axis = pointerAxis,
    };

    fn pointerEnter(data: ?*anyopaque, _: ?*anyopaque, serial: u32, _: ?*anyopaque, sx: i32, sy: i32) callconv(.c) void {
        const self: *Self = @ptrCast(@alignCast(data));
        self.serial = serial; // Capture serial for clipboard operations
        // Wayland uses fixed-point 24.8 format for surface coordinates
        self.mouse_x = sx >> 8;
        self.mouse_y = sy >> 8;
    }

    fn pointerLeave(_: ?*anyopaque, _: ?*anyopaque, _: u32, _: ?*anyopaque) callconv(.c) void {}

    fn pointerMotion(data: ?*anyopaque, _: ?*anyopaque, _: u32, sx: i32, sy: i32) callconv(.c) void {
        const self: *Self = @ptrCast(@alignCast(data));
        // Wayland uses fixed-point 24.8 format
        self.mouse_x = sx >> 8;
        self.mouse_y = sy >> 8;

        // Queue motion event
        if (self.mouse_event_count < backend.MAX_MOUSE_EVENTS) {
            self.mouse_events[self.mouse_event_count] = .{
                .x = self.mouse_x,
                .y = self.mouse_y,
                .button = .left,
                .event_type = .motion,
                .modifiers = self.modifier_state,
            };
            self.mouse_event_count += 1;
        } else {
            log.debug("mouse motion event dropped (queue full)", .{});
        }
    }

    fn pointerButton(data: ?*anyopaque, _: ?*anyopaque, serial: u32, _: u32, button_code: u32, state: u32) callconv(.c) void {
        const self: *Self = @ptrCast(@alignCast(data));
        self.serial = serial; // Capture serial for clipboard operations

        // Map Linux button codes to our MouseButton enum
        // BTN_LEFT = 0x110 (272), BTN_RIGHT = 0x111 (273), BTN_MIDDLE = 0x112 (274)
        const button: backend.MouseButton = switch (button_code) {
            272 => .left,
            273 => .right,
            274 => .middle,
            else => .left,
        };

        const event_type: backend.MouseEventType = if (state == 1) .press else .release;

        if (self.mouse_event_count < backend.MAX_MOUSE_EVENTS) {
            self.mouse_events[self.mouse_event_count] = .{
                .x = self.mouse_x,
                .y = self.mouse_y,
                .button = button,
                .event_type = event_type,
                .modifiers = self.modifier_state,
            };
            self.mouse_event_count += 1;
        } else {
            log.warn("mouse button event dropped (queue full), button={}", .{button_code});
        }
    }

    fn pointerAxis(data: ?*anyopaque, _: ?*anyopaque, _: u32, axis: u32, value: i32) callconv(.c) void {
        const self: *Self = @ptrCast(@alignCast(data));

        // axis: 0 = vertical, 1 = horizontal
        // value: positive = down/right, negative = up/left (fixed point 24.8)
        if (self.mouse_event_count < backend.MAX_MOUSE_EVENTS) {
            const button: backend.MouseButton = if (axis == 0)
                (if (value > 0) .scroll_down else .scroll_up)
            else
                (if (value > 0) .scroll_right else .scroll_left);

            self.mouse_events[self.mouse_event_count] = .{
                .x = self.mouse_x,
                .y = self.mouse_y,
                .button = button,
                .event_type = .press,
                .modifiers = self.modifier_state,
            };
            self.mouse_event_count += 1;
        } else {
            log.warn("mouse scroll event dropped (queue full), axis={}", .{axis});
        }
    }

    // ========================================================================
    // Clipboard support (wl_data_device)
    // ========================================================================

    const DataDeviceListener = extern struct {
        data_offer: *const fn (?*anyopaque, ?*anyopaque, ?*anyopaque) callconv(.c) void,
        enter: ?*const fn (?*anyopaque, ?*anyopaque, u32, ?*anyopaque, i32, i32, ?*anyopaque) callconv(.c) void,
        leave: ?*const fn (?*anyopaque, ?*anyopaque) callconv(.c) void,
        motion: ?*const fn (?*anyopaque, ?*anyopaque, u32, i32, i32) callconv(.c) void,
        drop: ?*const fn (?*anyopaque, ?*anyopaque) callconv(.c) void,
        selection: *const fn (?*anyopaque, ?*anyopaque, ?*anyopaque) callconv(.c) void,
    };

    const data_device_listener = DataDeviceListener{
        .data_offer = dataDeviceDataOffer,
        .enter = null,
        .leave = null,
        .motion = null,
        .drop = null,
        .selection = dataDeviceSelection,
    };

    fn dataDeviceDataOffer(data: ?*anyopaque, _: ?*anyopaque, offer: ?*anyopaque) callconv(.c) void {
        const self: *Self = @ptrCast(@alignCast(data));

        // New data offer - add listener to track mime types
        if (offer != null) {
            _ = wl_proxy_add_listener(offer.?, &data_offer_listener, self);
        }
    }

    fn dataDeviceSelection(data: ?*anyopaque, _: ?*anyopaque, offer: ?*anyopaque) callconv(.c) void {
        const self: *Self = @ptrCast(@alignCast(data));

        // Selection changed - store the offer for later use
        if (self.current_offer != null) {
            // wl_data_offer.destroy (opcode 1)
            _ = wl_proxy_marshal_flags(self.current_offer.?, 1, null, 1, 0);
            wl_proxy_destroy(self.current_offer.?);
        }
        self.current_offer = offer;
        self.pending_offer_mime = false;

        if (offer != null) {
            log.debug("clipboard selection changed", .{});
        }
    }

    const DataOfferListener = extern struct {
        offer: *const fn (?*anyopaque, ?*anyopaque, [*:0]const u8) callconv(.c) void,
        source_actions: ?*const fn (?*anyopaque, ?*anyopaque, u32) callconv(.c) void,
        action: ?*const fn (?*anyopaque, ?*anyopaque, u32) callconv(.c) void,
    };

    const data_offer_listener = DataOfferListener{
        .offer = dataOfferOffer,
        .source_actions = null,
        .action = null,
    };

    fn dataOfferOffer(data: ?*anyopaque, _: ?*anyopaque, mime_type: [*:0]const u8) callconv(.c) void {
        const self: *Self = @ptrCast(@alignCast(data));
        const mime = std.mem.span(mime_type);

        // Check for text mime types we can handle
        if (std.mem.eql(u8, mime, "text/plain;charset=utf-8") or
            std.mem.eql(u8, mime, "text/plain") or
            std.mem.eql(u8, mime, "UTF8_STRING") or
            std.mem.eql(u8, mime, "STRING"))
        {
            self.pending_offer_mime = true;
        }
    }

    const DataSourceListener = extern struct {
        target: ?*const fn (?*anyopaque, ?*anyopaque, [*:0]const u8) callconv(.c) void,
        send: *const fn (?*anyopaque, ?*anyopaque, [*:0]const u8, i32) callconv(.c) void,
        cancelled: *const fn (?*anyopaque, ?*anyopaque) callconv(.c) void,
        dnd_drop_performed: ?*const fn (?*anyopaque, ?*anyopaque) callconv(.c) void,
        dnd_finished: ?*const fn (?*anyopaque, ?*anyopaque) callconv(.c) void,
        action: ?*const fn (?*anyopaque, ?*anyopaque, u32) callconv(.c) void,
    };

    const data_source_listener = DataSourceListener{
        .target = null,
        .send = dataSourceSend,
        .cancelled = dataSourceCancelled,
        .dnd_drop_performed = null,
        .dnd_finished = null,
        .action = null,
    };

    fn dataSourceSend(data: ?*anyopaque, _: ?*anyopaque, _: [*:0]const u8, fd: i32) callconv(.c) void {
        const self: *Self = @ptrCast(@alignCast(data));

        // Write clipboard data to the fd
        if (self.clipboard_data) |clip_data| {
            _ = c.write(fd, clip_data.ptr, clip_data.len);
        }
        _ = c.close(fd);
    }

    fn dataSourceCancelled(data: ?*anyopaque, source: ?*anyopaque) callconv(.c) void {
        const self: *Self = @ptrCast(@alignCast(data));

        // Our data source is no longer valid
        if (source != null) {
            wl_proxy_destroy(source.?);
        }
        if (self.data_source == source) {
            self.data_source = null;
        }
    }

    /// Set clipboard content
    pub fn setClipboard(self: *Self, selection: u8, text: []const u8) !void {
        if (self.data_device_manager == null or self.data_device == null) {
            return error.ClipboardNotSupported;
        }

        // Only CLIPBOARD (selection=0) is supported via wl_data_device
        // PRIMARY selection requires zwp_primary_selection_device_manager_v1
        if (selection != 0) {
            log.debug("PRIMARY selection not supported on Wayland (need zwp_primary_selection)", .{});
            return error.ClipboardNotSupported;
        }

        // Store the data
        if (self.clipboard_data) |old| {
            self.allocator.free(old);
        }
        self.clipboard_data = try self.allocator.dupe(u8, text);

        // Destroy old data source
        if (self.data_source != null) {
            wl_proxy_destroy(self.data_source.?);
            self.data_source = null;
        }

        // Create new data source: wl_data_device_manager.create_data_source (opcode 0)
        self.data_source = wl_proxy_marshal_flags(
            self.data_device_manager.?,
            0, // create_data_source opcode
            &wl_data_source_interface,
            wl_proxy_get_version(self.data_device_manager.?),
            0,
        );

        if (self.data_source == null) {
            return error.DataSourceCreationFailed;
        }

        _ = wl_proxy_add_listener(self.data_source.?, &data_source_listener, self);

        // Offer mime types: wl_data_source.offer (opcode 0)
        _ = wl_proxy_marshal_flags(self.data_source.?, 0, null, 1, 0, @as([*:0]const u8, "text/plain;charset=utf-8"));
        _ = wl_proxy_marshal_flags(self.data_source.?, 0, null, 1, 0, @as([*:0]const u8, "text/plain"));
        _ = wl_proxy_marshal_flags(self.data_source.?, 0, null, 1, 0, @as([*:0]const u8, "UTF8_STRING"));
        _ = wl_proxy_marshal_flags(self.data_source.?, 0, null, 1, 0, @as([*:0]const u8, "STRING"));

        // Set selection: wl_data_device.set_selection (opcode 1)
        _ = wl_proxy_marshal_flags(
            self.data_device.?,
            1, // set_selection opcode
            null,
            wl_proxy_get_version(self.data_device.?),
            0,
            self.data_source.?,
            self.serial,
        );

        _ = wl_display_flush(self.display.?);
        log.debug("clipboard set: len={}", .{text.len});
    }

    /// Request clipboard content
    pub fn requestClipboard(self: *Self, selection: u8) void {
        if (self.current_offer == null or !self.pending_offer_mime) {
            return;
        }

        // Only CLIPBOARD supported
        if (selection != 0) {
            return;
        }

        self.clipboard_request_pending = true;
        self.clipboard_request_selection = selection;

        // Create pipe
        var pipe_fds: [2]c_int = undefined;
        if (c.pipe(&pipe_fds) < 0) {
            self.clipboard_request_pending = false;
            return;
        }

        // Request data: wl_data_offer.receive (opcode 0)
        _ = wl_proxy_marshal_flags(
            self.current_offer.?,
            0, // receive opcode
            null,
            1,
            0,
            @as([*:0]const u8, "text/plain;charset=utf-8"),
            pipe_fds[1],
        );
        _ = c.close(pipe_fds[1]); // Close write end

        _ = wl_display_flush(self.display.?);

        // Read data from pipe (non-blocking)
        var buffer: [65536]u8 = undefined;
        var total_read: usize = 0;

        // Set non-blocking
        _ = c.fcntl(pipe_fds[0], c.F_SETFL, c.O_NONBLOCK);

        // Poll for data with timeout
        var pfd = posix.pollfd{
            .fd = pipe_fds[0],
            .events = posix.POLL.IN,
            .revents = 0,
        };

        const ready = posix.poll(@as(*[1]posix.pollfd, &pfd), 100) catch 0; // 100ms timeout
        if (ready > 0) {
            while (total_read < buffer.len) {
                const n = c.read(pipe_fds[0], buffer[total_read..].ptr, buffer.len - total_read);
                if (n <= 0) break;
                total_read += @intCast(n);
            }
        }

        _ = c.close(pipe_fds[0]);

        if (total_read > 0) {
            if (self.clipboard_data) |old| {
                self.allocator.free(old);
            }
            self.clipboard_data = self.allocator.dupe(u8, buffer[0..total_read]) catch null;
            log.debug("clipboard received: {} bytes", .{total_read});
        }

        self.clipboard_request_pending = false;
    }

    /// Get clipboard data
    pub fn getClipboardData(self: *Self, selection: u8) ?[]const u8 {
        if (selection == 0) {
            return self.clipboard_data;
        } else {
            return self.primary_data;
        }
    }

    /// Check if clipboard request is pending
    pub fn isClipboardRequestPending(self: *Self) bool {
        return self.clipboard_request_pending;
    }

    // ========================================================================
    // SDCS Command Execution
    // ========================================================================

    fn executeSdcs(self: *Self, fb: []u8, data: []const u8) !void {
        if (data.len < 64) return error.InvalidSdcs;

        var offset: usize = 64;

        while (offset + 32 <= data.len) {
            const chunk_payload_bytes = std.mem.readInt(u64, data[offset + 24 ..][0..8], .little);
            offset += 32;

            if (offset + chunk_payload_bytes > data.len) break;

            const chunk_end = offset + @as(usize, @intCast(chunk_payload_bytes));
            try self.executeChunkCommands(fb, data[offset..chunk_end]);

            offset = chunk_end;
            offset = std.mem.alignForward(usize, offset, 8);
        }
    }

    fn executeChunkCommands(self: *Self, fb: []u8, commands: []const u8) !void {
        var offset: usize = 0;

        while (offset + 8 <= commands.len) {
            const opcode = std.mem.readInt(u16, commands[offset..][0..2], .little);
            const payload_len = std.mem.readInt(u32, commands[offset + 4 ..][0..4], .little);
            offset += 8;

            if (offset + payload_len > commands.len) break;

            const payload = commands[offset..][0..payload_len];
            try self.executeCommand(fb, opcode, payload);

            offset += payload_len;
            const record_bytes = 8 + payload_len;
            const pad = (8 - (record_bytes % 8)) % 8;
            offset += pad;

            if (opcode == 0x00F0) break;
        }
    }

    fn executeCommand(self: *Self, fb: []u8, opcode: u16, payload: []const u8) !void {
        switch (opcode) {
            0x0001 => {}, // RESET
            0x0004 => {}, // SET_BLEND
            0x0010 => { // FILL_RECT
                if (payload.len >= 32) {
                    const x = readF32(payload[0..4]);
                    const y = readF32(payload[4..8]);
                    const w = readF32(payload[8..12]);
                    const h = readF32(payload[12..16]);
                    const r = readF32(payload[16..20]);
                    const g = readF32(payload[20..24]);
                    const b_col = readF32(payload[24..28]);
                    const a = readF32(payload[28..32]);
                    self.fillRect(fb, x, y, w, h, r, g, b_col, a);
                }
            },
            0x0030 => { // DRAW_GLYPH_RUN
                if (payload.len >= 48) {
                    self.drawGlyphRun(fb, payload);
                }
            },
            0x00F0 => {}, // END
            else => {},
        }
    }

    fn fillRect(self: *Self, fb: []u8, x: f32, y: f32, w: f32, h: f32, r: f32, g: f32, b_col: f32, a: f32) void {
        const fb_w = self.width;
        const fb_h = self.height;

        const x0: i32 = @intFromFloat(@max(0, x));
        const y0: i32 = @intFromFloat(@max(0, y));
        const x1: i32 = @intFromFloat(@min(@as(f32, @floatFromInt(fb_w)), x + w));
        const y1: i32 = @intFromFloat(@min(@as(f32, @floatFromInt(fb_h)), y + h));

        if (x0 >= x1 or y0 >= y1) return;

        // Wayland ARGB format
        const ca: u8 = clampU8(a);
        const cr: u8 = clampU8(r);
        const cg: u8 = clampU8(g);
        const cb: u8 = clampU8(b_col);

        const pixels: [*]u32 = @ptrCast(@alignCast(fb.ptr));

        var py: i32 = y0;
        while (py < y1) : (py += 1) {
            var px: i32 = x0;
            while (px < x1) : (px += 1) {
                const idx = @as(usize, @intCast(py)) * @as(usize, fb_w) + @as(usize, @intCast(px));
                if (idx < fb_w * fb_h) {
                    if (ca == 255) {
                        pixels[idx] = (@as(u32, ca) << 24) | (@as(u32, cr) << 16) | (@as(u32, cg) << 8) | @as(u32, cb);
                    } else if (ca > 0) {
                        const sa: f32 = @as(f32, @floatFromInt(ca)) / 255.0;
                        const existing = pixels[idx];
                        const da: f32 = @as(f32, @floatFromInt((existing >> 24) & 0xFF)) / 255.0;
                        const out_a = sa + da * (1.0 - sa);

                        if (out_a > 0) {
                            const dr: u8 = @intCast((existing >> 16) & 0xFF);
                            const dg: u8 = @intCast((existing >> 8) & 0xFF);
                            const db: u8 = @intCast(existing & 0xFF);
                            const new_a: u8 = @intFromFloat(@min(255.0, out_a * 255.0));
                            const new_r = blendChannel(cr, dr, sa, da, out_a);
                            const new_g = blendChannel(cg, dg, sa, da, out_a);
                            const new_b = blendChannel(cb, db, sa, da, out_a);
                            pixels[idx] = (@as(u32, new_a) << 24) | (@as(u32, new_r) << 16) | (@as(u32, new_g) << 8) | @as(u32, new_b);
                        }
                    }
                }
            }
        }
    }

    fn drawGlyphRun(self: *Self, fb: []u8, payload: []const u8) void {
        const base_x = readF32(payload[0..4]);
        const base_y = readF32(payload[4..8]);
        const r = readF32(payload[8..12]);
        const g = readF32(payload[12..16]);
        const b_col = readF32(payload[16..20]);
        const a = readF32(payload[20..24]);
        const cell_width = std.mem.readInt(u32, payload[24..28], .little);
        const cell_height = std.mem.readInt(u32, payload[28..32], .little);
        const atlas_cols = std.mem.readInt(u32, payload[32..36], .little);
        const atlas_width = std.mem.readInt(u32, payload[36..40], .little);
        const atlas_height = std.mem.readInt(u32, payload[40..44], .little);
        const glyph_count = std.mem.readInt(u32, payload[44..48], .little);

        if (cell_width == 0 or cell_height == 0 or atlas_cols == 0) return;

        const glyphs_offset: usize = 48;
        const glyphs_size = glyph_count * 12;
        const atlas_offset = glyphs_offset + glyphs_size;
        const atlas_size = @as(usize, atlas_width) * @as(usize, atlas_height);

        if (payload.len < atlas_offset + atlas_size) return;

        const atlas_data = payload[atlas_offset..][0..atlas_size];
        const cr: u8 = clampU8(r);
        const cg: u8 = clampU8(g);
        const cb: u8 = clampU8(b_col);

        var i: u32 = 0;
        while (i < glyph_count) : (i += 1) {
            const glyph_off = glyphs_offset + i * 12;
            if (glyph_off + 12 > payload.len) break;

            const glyph_index = std.mem.readInt(u32, payload[glyph_off..][0..4], .little);
            const x_offset = readF32(payload[glyph_off + 4 ..][0..4]);
            const y_offset = readF32(payload[glyph_off + 8 ..][0..4]);

            const atlas_col = glyph_index % atlas_cols;
            const atlas_row = glyph_index / atlas_cols;
            const atlas_x = atlas_col * cell_width;
            const atlas_y = atlas_row * cell_height;

            self.blitGlyph(fb, base_x + x_offset, base_y + y_offset, cell_width, cell_height, atlas_data, atlas_width, atlas_x, atlas_y, cr, cg, cb, a);
        }
    }

    fn blitGlyph(self: *Self, fb: []u8, dst_x: f32, dst_y: f32, cell_w: u32, cell_h: u32, atlas: []const u8, atlas_w: u32, atlas_x: u32, atlas_y: u32, r: u8, g: u8, b: u8, base_alpha: f32) void {
        const fb_w = self.width;
        const fb_h = self.height;
        const pixels: [*]u32 = @ptrCast(@alignCast(fb.ptr));

        var cy: u32 = 0;
        while (cy < cell_h) : (cy += 1) {
            var cx: u32 = 0;
            while (cx < cell_w) : (cx += 1) {
                const px: i32 = @as(i32, @intFromFloat(dst_x)) + @as(i32, @intCast(cx));
                const py: i32 = @as(i32, @intFromFloat(dst_y)) + @as(i32, @intCast(cy));

                if (px < 0 or py < 0) continue;
                if (px >= @as(i32, @intCast(fb_w)) or py >= @as(i32, @intCast(fb_h))) continue;

                const ax = atlas_x + cx;
                const ay = atlas_y + cy;
                if (ax >= atlas_w or ay * atlas_w + ax >= atlas.len) continue;

                const atlas_alpha = atlas[ay * atlas_w + ax];
                if (atlas_alpha == 0) continue;

                const glyph_a: f32 = @as(f32, @floatFromInt(atlas_alpha)) / 255.0;
                const final_a: f32 = glyph_a * base_alpha;
                const ca: u8 = @intFromFloat(final_a * 255.0);

                if (ca == 0) continue;

                const idx = @as(usize, @intCast(py)) * @as(usize, fb_w) + @as(usize, @intCast(px));
                if (idx >= fb_w * fb_h) continue;

                if (ca == 255) {
                    pixels[idx] = (255 << 24) | (@as(u32, r) << 16) | (@as(u32, g) << 8) | @as(u32, b);
                } else {
                    const existing = pixels[idx];
                    const da: f32 = @as(f32, @floatFromInt((existing >> 24) & 0xFF)) / 255.0;
                    const out_a = final_a + da * (1.0 - final_a);

                    if (out_a > 0) {
                        const dr: u8 = @intCast((existing >> 16) & 0xFF);
                        const dg: u8 = @intCast((existing >> 8) & 0xFF);
                        const db: u8 = @intCast(existing & 0xFF);
                        const new_a: u8 = @intFromFloat(@min(255.0, out_a * 255.0));
                        const new_r = blendChannel(r, dr, final_a, da, out_a);
                        const new_g = blendChannel(g, dg, final_a, da, out_a);
                        const new_b = blendChannel(b, db, final_a, da, out_a);
                        pixels[idx] = (@as(u32, new_a) << 24) | (@as(u32, new_r) << 16) | (@as(u32, new_g) << 8) | @as(u32, new_b);
                    }
                }
            }
        }
    }

    // ========================================================================
    // Backend interface
    // ========================================================================

    fn getCapabilitiesImpl(_: *anyopaque) backend.Capabilities {
        return .{
            .name = "wayland",
            .max_width = 8192,
            .max_height = 8192,
            .supports_aa = true,
            .hardware_accelerated = false,
            .can_present = true,
        };
    }

    fn initFramebufferImpl(ctx: *anyopaque, config: backend.FramebufferConfig) anyerror!void {
        const self: *Self = @ptrCast(@alignCast(ctx));

        if (config.width != self.width or config.height != self.height) {
            try self.createBuffer(config.width, config.height);
        }
    }

    fn renderImpl(ctx: *anyopaque, request: backend.RenderRequest) anyerror!backend.RenderResult {
        const self: *Self = @ptrCast(@alignCast(ctx));
        const start_time = std.time.nanoTimestamp();

        // Mark as rendering to prevent resize during render
        self.rendering = true;
        defer {
            self.rendering = false;
            // Process any pending resize after rendering completes
            if (self.pending_resize) |resize| {
                self.pending_resize = null;
                self.createBuffer(resize.width, resize.height) catch |err| {
                    log.err("deferred resize failed: {}", .{err});
                };
            }
        }

        if (!self.processEvents()) {
            return backend.RenderResult.failure(request.surface_id, "window closed");
        }

        const fb = self.shm_data orelse {
            return backend.RenderResult.failure(request.surface_id, "no framebuffer");
        };

        // Clear if requested (ARGB format)
        if (request.clear_color) |color| {
            const a: u8 = @intFromFloat(@min(255.0, @max(0.0, color[3] * 255.0)));
            const r: u8 = @intFromFloat(@min(255.0, @max(0.0, color[0] * 255.0)));
            const g: u8 = @intFromFloat(@min(255.0, @max(0.0, color[1] * 255.0)));
            const b: u8 = @intFromFloat(@min(255.0, @max(0.0, color[2] * 255.0)));

            const pixel: u32 = (@as(u32, a) << 24) | (@as(u32, r) << 16) | (@as(u32, g) << 8) | @as(u32, b);

            const pixels: [*]u32 = @ptrCast(@alignCast(fb));
            const count = self.width * self.height;
            for (0..count) |i| {
                pixels[i] = pixel;
            }
        }

        // Execute SDCS commands
        self.executeSdcs(fb[0..self.shm_size], request.sdcs_data) catch |err| {
            log.warn("SDCS execution failed: {}", .{err});
        };

        // Present
        self.present();

        self.frame_count += 1;
        const end_time = std.time.nanoTimestamp();

        return backend.RenderResult.success(
            request.surface_id,
            self.frame_count,
            @intCast(end_time - start_time),
        );
    }

    fn getPixelsImpl(ctx: *anyopaque) ?[]u8 {
        const self: *Self = @ptrCast(@alignCast(ctx));
        if (self.shm_data) |data| {
            return data[0..self.shm_size];
        }
        return null;
    }

    fn resizeImpl(ctx: *anyopaque, width: u32, height: u32) anyerror!void {
        const self: *Self = @ptrCast(@alignCast(ctx));
        try self.createBuffer(width, height);
    }

    fn pollEventsImpl(ctx: *anyopaque) bool {
        const self: *Self = @ptrCast(@alignCast(ctx));
        return self.processEvents();
    }

    fn deinitImpl(ctx: *anyopaque) void {
        const self: *Self = @ptrCast(@alignCast(ctx));
        self.deinit();
    }

    fn getKeyEventsImpl(ctx: *anyopaque) []const backend.KeyEvent {
        const self: *Self = @ptrCast(@alignCast(ctx));
        const count = self.key_event_count;
        self.key_event_count = 0; // Clear the queue
        return self.key_events[0..count];
    }

    fn getMouseEventsImpl(ctx: *anyopaque) []const backend.MouseEvent {
        const self: *Self = @ptrCast(@alignCast(ctx));
        const count = self.mouse_event_count;
        self.mouse_event_count = 0; // Clear the queue
        return self.mouse_events[0..count];
    }

    fn setClipboardImpl(ctx: *anyopaque, selection: u8, text: []const u8) anyerror!void {
        const self: *Self = @ptrCast(@alignCast(ctx));
        return self.setClipboard(selection, text);
    }

    fn requestClipboardImpl(ctx: *anyopaque, selection: u8) void {
        const self: *Self = @ptrCast(@alignCast(ctx));
        self.requestClipboard(selection);
    }

    fn getClipboardDataImpl(ctx: *anyopaque, selection: u8) ?[]const u8 {
        const self: *Self = @ptrCast(@alignCast(ctx));
        return self.getClipboardData(selection);
    }

    fn isClipboardPendingImpl(ctx: *anyopaque) bool {
        const self: *Self = @ptrCast(@alignCast(ctx));
        return self.isClipboardRequestPending();
    }

    pub const vtable = backend.Backend.VTable{
        .getCapabilities = getCapabilitiesImpl,
        .initFramebuffer = initFramebufferImpl,
        .render = renderImpl,
        .getPixels = getPixelsImpl,
        .resize = resizeImpl,
        .pollEvents = pollEventsImpl,
        .getKeyEvents = getKeyEventsImpl,
        .getMouseEvents = getMouseEventsImpl,
        .setClipboard = setClipboardImpl,
        .requestClipboard = requestClipboardImpl,
        .getClipboardData = getClipboardDataImpl,
        .isClipboardPending = isClipboardPendingImpl,
        .deinit = deinitImpl,
    };

    pub fn toBackend(self: *Self) backend.Backend {
        return .{
            .ptr = self,
            .vtable = &vtable,
        };
    }
};

/// Create a Wayland backend
pub fn create(allocator: std.mem.Allocator) !backend.Backend {
    const wl = try WaylandBackend.init(allocator);
    return wl.toBackend();
}

// ============================================================================
// Helper functions
// ============================================================================

fn clampU8(v: f32) u8 {
    var x = v;
    if (x < 0.0) x = 0.0;
    if (x > 1.0) x = 1.0;
    return @intFromFloat(@round(x * 255.0));
}

fn readF32(bytes: *const [4]u8) f32 {
    const u = std.mem.readInt(u32, bytes, .little);
    return @bitCast(u);
}

fn blendChannel(src: u8, dst: u8, sa: f32, da: f32, out_a: f32) u8 {
    const s: f32 = @floatFromInt(src);
    const d: f32 = @floatFromInt(dst);
    const result = (s * sa + d * da * (1.0 - sa)) / out_a;
    return @intFromFloat(@min(255.0, @max(0.0, result)));
}
